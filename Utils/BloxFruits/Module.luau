local Settings, Connections = ...

local _ENV = (getgenv or getrenv or getfenv)()

if type(Settings) ~= "table" or type(Connections) ~= "table" then
	return {}
end

local VirtualInputManager: VirtualInputManager = game:GetService("VirtualInputManager")
local CollectionService: CollectionService = game:GetService("CollectionService")
local ReplicatedStorage: ReplicatedStorage = game:GetService("ReplicatedStorage")
local TeleportService: TeleportService = game:GetService("TeleportService")
local RunService: RunService = game:GetService("RunService")
local Players: Players = game:GetService("Players")

local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local GunValidator: RemoteEvent = Remotes:WaitForChild("Validator2")
local CommF: RemoteFunction = Remotes:WaitForChild("CommF_")
local CommE: RemoteEvent = Remotes:WaitForChild("CommE")

local ChestModels: Folder = workspace:WaitForChild("ChestModels")
local WorldOrigin: Folder = workspace:WaitForChild("_WorldOrigin")
local Characters: Folder = workspace:WaitForChild("Characters")
local SeaBeasts: Folder = workspace:WaitForChild("SeaBeasts")
local Enemies: Folder = workspace:WaitForChild("Enemies")
local Boats: Folder = workspace:WaitForChild("Boats")
local Map: Model = workspace:WaitForChild("Map")

local EnemySpawns: Folder = WorldOrigin:WaitForChild("EnemySpawns")
local Locations: Folder = WorldOrigin:WaitForChild("Locations")

local RenderStepped = RunService.RenderStepped
local Heartbeat = RunService.Heartbeat
local Stepped = RunService.Stepped
local Player = Players.LocalPlayer

local Data: Folder = Player:WaitForChild("Data")
local Level: IntValue = Data:WaitForChild("Level")
local Fragments: IntValue = Data:WaitForChild("Fragments")
local Money: IntValue = Data:WaitForChild("Beli")

local Modules: Folder? = ReplicatedStorage:WaitForChild("Modules")
local Net: ModuleScript = Modules:WaitForChild("Net")

local EXECUTOR_NAME: string = string.upper(if identifyexecutor then identifyexecutor() else "NULL")
local IS_BLACKLISTED_EXECUTOR: boolean? = table.find({"NULL", "XENO", "JJSPLOIT"}, EXECUTOR_NAME)

local hookmetamethod = (not IS_BLACKLISTED_EXECUTOR and hookmetamethod) or (function(...) return ... end)
local hookfunction = (not IS_BLACKLISTED_EXECUTOR and hookfunction) or (function(...) return ... end)
local sethiddenproperty = sethiddenproperty or (function(...) return ... end)

local setupvalue: (any, number, any?) -> (nil) = setupvalue or (debug and debug.setupvalue)
local getupvalue: (any, number) -> any = getupvalue or (debug and debug.getupvalue)

local BRING_TAG: string = _ENV._Bring_Tag or `b{math.random(80, 2e4)}t`
local KILLAURA_TAG: string = _ENV._KillAura_Tag or `k{math.random(120, 2e4)}t`

local ServerOwnerId: IntValue = ReplicatedStorage:FindFirstChild("PrivateServerOwnerId")
local IsPrivateServer: boolean = if ServerOwnerId then ServerOwnerId.Value ~= 0 else true

local WaitSeconds = nil;

local HIDDEN_SETTINGS: { [string]: any } = {
	SKILL_COOLDOWN = 0.5,
	CLEAR_AFTER = 50,
	
	SILENT_AIM_ENABLED = true,
	WALKSPEED_BYPASS_ENABLED = true
}

_ENV._Bring_Tag = BRING_TAG
_ENV._KillAura_Tag = KILLAURA_TAG

local HitboxLimbs = {"RightLowerArm", "RightUpperArm", "LeftLowerArm", "LeftUpperArm", "RightHand", "LeftHand"};

local function GetEnemyName(string: string): string
	return (string:find("Lv. ") and string:gsub(" %pLv. %d+%p", "") or string):gsub(" %pBoss%p", "")
end

local function CheckPlayerAlly(__Player: Player): boolean
	if __Player.Parent == Characters then
		__Player = Players:GetPlayerFromCharacter(__Player)
	end
	
	if tostring(__Player.Team) == "Marines" and __Player.Team == Player.Team then
		return false
	elseif __Player:HasTag(`Ally{Player.Name}`) or Player:HasTag(`Ally{__Player.Name}`) then
		return false
	end
	
	return true
end

local function WaitChilds(Instance: Instance, ...): Instance?
	for _, Children: string in {...} do
		Instance = if Instance then Instance:WaitForChild(Children, WaitSeconds) else nil
	end
	
	return Instance
end

local function FastWait(Seconds: number, Instance: Instance, ...): Instance?
	WaitSeconds = if type(Seconds) == "number" then Seconds else nil
	local Success, _Instance = pcall(WaitChilds, Instance, ...)
	WaitSeconds = nil
	
	return if Success then _Instance else nil
end

local function CreateNewClear()
	local COUNT_NEWINDEX = 0
	
	return {
		__newindex = function(self, index, value)
			if COUNT_NEWINDEX >= HIDDEN_SETTINGS.CLEAR_AFTER then
				for key, cache in self do
					if typeof(cache) == "Instance" and not cache:IsDescendantOf(game) then
						rawset(self, key, nil)
					end
				end
				COUNT_NEWINDEX = 0
			end
			
			COUNT_NEWINDEX += 1
			return rawset(self, index, value)
		end
	}
end

function CreateDictionary(array: { string? }, value: any?): { [string]: any? }
	local Dictionary = {}
	
	for _, string in ipairs(array) do
		Dictionary[string] = if type(value) == "table" then {} else value
	end
	
	return Dictionary
end

local HumanoidsCache do
	local Metatable = CreateNewClear()
	Metatable.__index = function(self, Character)
		local Humanoid = Character:FindFirstChild(if Character.Parent == SeaBeasts then "Health" else "Humanoid")
		
		if Humanoid then
			self[Character] = Humanoid
			return Humanoid
		end
	end
	
	HumanoidsCache = setmetatable({}, Metatable)
end

local function GetHuamnoidHealth(Humanoid: Humanoid): number
	return Humanoid[if Humanoid.ClassName == "Humanoid" then "Health" else "Value"]
end

local function DistanceFromCharacter(Value: CFrame | BasePart): number
	return Player:DistanceFromCharacter(Value.Position)
end

local function IsAlive(Character, _Humanoid)
	if _Humanoid then
		return GetHuamnoidHealth(_Humanoid) > 0
	elseif Character then
		local Humanoid = HumanoidsCache[Character]
		
		if Humanoid then
			return GetHuamnoidHealth(Humanoid) > 0
		else
			return Character.Parent == Boats
		end
	end
end

local function FireRemote(...)
	return CommF:InvokeServer(...)
end

local function GetRandomHitboxLimb(Character)
	return Character:FindFirstChild(HitboxLimbs[math.random(#HitboxLimbs)])
end

local Signal = {} do
	local Connection = {} do
		Connection.__index = Connection
		
		function Connection:Disconnect(): (nil)
			if not self.Connected then
				return nil
			end
			
			local find = table.find(self.Signal, self)
			
			if find then
				table.remove(self.Signal, find)
			end
			
			self.Function = nil
			self.Connected = false
		end
		
		function Connection:Fire(...): (nil)
			if not self.Function then
				return nil
			end
			
			task.spawn(self.Function, ...)
		end
		
		function Connection.new(): Connection
			return setmetatable({
				Connected = true
			}, Connection)
		end
		
		setmetatable(Connection, {
			__index = function(self, index)
				error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(index)), 2)
			end,
			__newindex = function(tb, key, value)
				error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
			end
		})
	end
	
	Signal.__index = Signal
	
	function Signal:Connect(Function): Connection
		if type(Function) ~= "function" then
			return nil
		end
		
		local NewConnection = Connection.new()
		NewConnection.Function = Function
		NewConnection.Signal = self
		
		table.insert(self.Connections, NewConnection)
		return NewConnection
	end
	
	function Signal:Once(Function): (nil)
		local Connection;
		Connection = self:Connect(function(...)
			Function(...)
			Connection:Disconnect()
		end)
		return Connection
	end
	
	function Signal:Wait(): any?
		local WaitingCoroutine = coroutine.running()
		local Connection;Connection = self:Connect(function(...)
			Connection:Disconnect()
			task.spawn(WaitingCoroutine, ...)
		end)
		return coroutine.yield()
	end
	
	function Signal:Fire(...): (nil)
		for _, Connection in ipairs(self.Connections) do
			if Connection.Connected then
				Connection:Fire(...)
			end
		end
	end
	
	function Signal.new(): Signal
		return setmetatable({
			Connections = {}
		}, Signal)
	end
	
	setmetatable(Signal, {
		__index = function(self, index)
			error(`Attempt to get Signal::{ tostring(index) } (not a valid member)`, 2)
		end,
		__newindex = function(self, index, value)
			error(`Attempt to set Signal::{ tostring(index) } (not a valid member)`, 2)
		end
	})
end

local Module = {} do
	local Cached = {
		Closest = nil,
		Equipped = nil,
		RealFruitsName = setmetatable({}, CreateNewClear()),
		RealFruitsId = setmetatable({}, CreateNewClear()),
		Enemies = {}, -- setmetatable({}, CreateNewClear()),
		Progress = {},
		Bring = {},
		Tools = {}
	}
	
	local Debounces = {
		TargetDebounce = 0,
		UpdateDebounce = 0,
		GetEnemy = 0,
		Skills = {}
	}
	
	Module.GameData = {
		Sea = ({ [2753915549] = 1, [4442272183] = 2, [7449423635] = 3 })[game.PlaceId] or 0;
		SeasName = { "Main", "Dressrosa", "Zou" };
		MaxMastery = 600;
		MaxLevel = 2650;
		
		StringVersion = require(ReplicatedStorage.BuildInfo).VERSION;
	}
	
	Module.GameData.NumberVersion = (function()
		local SplitVersion = string.split(string.sub(Module.GameData.StringVersion, 2, -1), ".")
		local CurrentVersion = `{ SplitVersion[1] or 0 }.`;
		
		for i = 2, #SplitVersion do
			CurrentVersion ..= tostring(SplitVersion[i] or 0)
		end
		
		return tonumber(CurrentVersion) or 0
	end)()
	
	do
		Module.FruitsId = {
			["rbxassetid://15124425041"] = "Rocket",
			["rbxassetid://15123685330"] = "Spin",
			["rbxassetid://15123613404"] = "Blade",
			["rbxassetid://15123689268"] = "Spring",
			["rbxassetid://15123595806"] = "Bomb",
			["rbxassetid://15123677932"] = "Smoke",
			["rbxassetid://15124220207"] = "Spike",
			["rbxassetid://121545956771325"] = "Flame",
			["rbxassetid://15123673019"] = "Sand",
			["rbxassetid://15123618591"] = "Dark",
			["rbxassetid://77885466312115"] = "Eagle",
			["rbxassetid://15112600534"] = "Diamond",
			["rbxassetid://15123640714"] = "Light",
			["rbxassetid://15123668008"] = "Rubber",
			["rbxassetid://15123662036"] = "Ghost",
			["rbxassetid://15123645682"] = "Magma",
			["rbxassetid://15123606541"] = "Quake",
			["rbxassetid://15123606541"] = "Buddha",
			["rbxassetid://15123643097"] = "Love",
			["rbxassetid://15123681598"] = "Spider",
			["rbxassetid://116828771482820"] = "Creation",
			["rbxassetid://15123679712"] = "Sound",
			["rbxassetid://15123654553"] = "Phoenix",
			["rbxassetid://15123656798"] = "Portal",
			["rbxassetid://15123670514"] = "Rumble",
			["rbxassetid://15123652069"] = "Pain",
			["rbxassetid://15123587371"] = "Blizzard",
			["rbxassetid://15123633312"] = "Gravity",
			["rbxassetid://15123648309"] = "Mammoth",
			["rbxassetid://15694681122"] = "T-Rex",
			["rbxassetid://15123624401"] = "Dough",
			["rbxassetid://15123675904"] = "Shadow",
			["rbxassetid://10773719142"] = "Venom",
			["rbxassetid://15123616275"] = "Control",
			["rbxassetid://11911905519"] = "Spirit",
			["rbxassetid://15123638064"] = "Leopard",
			["rbxassetid://15487764876"] = "Kitsune",
			["rbxassetid://115276580506154"] = "Yeti",
			["rbxassetid://118054805452821"] = "Gas",
			["rbxassetid://95749033139458"] = "Dragon East"
		}
		
		Module.Bosses = {
			-- Bosses Sea 1
			["Saber Expert"] = {
				NoQuest = true,
				Position = CFrame.new(-1461, 30, -51)
			},
			["The Saw"] = {
				RaidBoss = true,
				Position = CFrame.new(-690, 15, 1583)
			},
			["Greybeard"] = {
				RaidBoss = true,
				Position = CFrame.new(-5043, 25, 4262)
			},
			["The Gorilla King"] = {
				IsBoss = true,
				Level = 20,
				Position = CFrame.new(-1128, 6, -451),
				Quest = {"JungleQuest", CFrame.new(-1598, 37, 153)}
			},
			["Chef"] = {
				IsBoss = true,
				Level = 55,
				Position = CFrame.new(-1131, 14, 4080),
				Quest = {"BuggyQuest1", CFrame.new(-1140, 4, 3829)}
			},
			["Yeti"] = {
				IsBoss = true,
				Level = 105,
				Position = CFrame.new(1185, 106, -1518),
				Quest = {"SnowQuest", CFrame.new(1385, 87, -1298)}
			},
			["Vice Admiral"] = {
				IsBoss = true,
				Level = 130,
				Position = CFrame.new(-4807, 21, 4360),
				Quest = {"MarineQuest2", CFrame.new(-5035, 29, 4326), 2}
			},
			["Swan"] = {
				IsBoss = true,
				Level = 240,
				Position = CFrame.new(5230, 4, 749),
				Quest = {"ImpelQuest", CFrame.new(5191, 4, 692)}
			},
			["Chief Warden"] = {
				IsBoss = true,
				Level = 230,
				Position = CFrame.new(5230, 4, 749),
				Quest = {"ImpelQuest", CFrame.new(5191, 4, 692), 2}
			},
			["Warden"] = {
				IsBoss = true,
				Level = 220,
				Position = CFrame.new(5230, 4, 749),
				Quest = {"ImpelQuest", CFrame.new(5191, 4, 692), 1}
			},
			["Magma Admiral"] = {
				IsBoss = true,
				Level = 350,
				Position = CFrame.new(-5694, 18, 8735),
				Quest = {"MagmaQuest", CFrame.new(-5319, 12, 8515)}
			},
			["Fishman Lord"] = {
				IsBoss = true,
				Level = 425,
				Position = CFrame.new(61350, 31, 1095),
				Quest = {"FishmanQuest", CFrame.new(61122, 18, 1567)}
			},
			["Wysper"] = {
				IsBoss = true,
				Level = 500,
				Position = CFrame.new(-7927, 5551, -637),
				Quest = {"SkyExp1Quest", CFrame.new(-7861, 5545, -381)}
			},
			["Thunder God"] = {
				IsBoss = true,
				Level = 575,
				Position = CFrame.new(-7751, 5607, -2315),
				Quest = {"SkyExp2Quest", CFrame.new(-7903, 5636, -1412)}
			},
			["Cyborg"] = {
				IsBoss = true,
				Level = 675,
				Position = CFrame.new(6138, 10, 3939),
				Quest = {"FountainQuest", CFrame.new(5258, 39, 4052)}
			},
			
			-- Bosses Sea 2
			["Don Swan"] = {
				RaidBoss = true,
				Position = CFrame.new(2289, 15, 808)
			},
			["Cursed Captain"] = {
				RaidBoss = true,
				Position = CFrame.new(912, 186, 33591)
			},
			["Darkbeard"] = {
				RaidBoss = true,
				Position = CFrame.new(3695, 13, -3599)
			},
			["Diamond"] = {
				IsBoss = true,
				Level = 750,
				Position = CFrame.new(-1569, 199, -31),
				Quest = {"Area1Quest", CFrame.new(-427, 73, 1835)}
			},
			["Jeremy"] = {
				IsBoss = true,
				Level = 850,
				Position = CFrame.new(2316, 449, 787),
				Quest = {"Area2Quest", CFrame.new(635, 73, 919)}
			},
			["Orbitus"] = {
				IsBoss = true,
				Level = 925,
				Position = CFrame.new(-2086, 73, -4208),
				Quest = {"MarineQuest3", CFrame.new(-2441, 73, -3219)}
			},
			["Smoke Admiral"] = {
				IsBoss = true,
				Level = 1150,
				Position = CFrame.new(-5078, 24, -5352),
				Quest = {"IceSideQuest", CFrame.new(-6061, 16, -4904)}
			},
			["Awakened Ice Admiral"] = {
				IsBoss = true,
				Level = 1400,
				Position = CFrame.new(6473, 297, -6944),
				Quest = {"FrostQuest", CFrame.new(5668, 28, -6484)}
			},
			["Tide Keeper"] = {
				IsBoss = true,
				Level = 1475,
				Position = CFrame.new(-3711, 77, -11469),
				Quest = {"ForgottenQuest", CFrame.new(-3056, 240, -10145)}
			},
			
			-- Bosses Sea 3
			["Tyrant of the Skies"] = {
				RaidBoss = true,
				Position = CFrame.new(-16252, 153, 1394)
			},
			["Cake Prince"] = {
				RaidBoss = true,
				Position = CFrame.new(-2103, 70, -12165)
			},
			["Dough King"] = {
				RaidBoss = true,
				Position = CFrame.new(-2103, 70, -12165)
			},
			["rip_indra True Form"] = {
				RaidBoss = true,
				Position = CFrame.new(-5333, 424, -2673)
			},
			["Stone"] = {
				IsBoss = true,
				Level = 1550,
				Position = CFrame.new(-1049, 40, 6791),
				Quest = {"PiratePortQuest", CFrame.new(-449, 109, 5950)}
			},
			["Hydra Leader"] = {
				IsBoss = true,
				Level = 1675,
				Position = CFrame.new(5836, 1019, -83),
				Quest = {"VenomCrewQuest", CFrame.new(5214, 1004, 761)}
			},
			["Kilo Admiral"] = {
				IsBoss = true,
				Level = 1750,
				Position = CFrame.new(2904, 509, -7349),
				Quest = {"MarineTreeIsland", CFrame.new(2485, 74, -6788)}
			},
			["Captain Elephant"] = {
				IsBoss = true,
				Level = 1875,
				Position = CFrame.new(-13393, 319, -8423),
				Quest = {"DeepForestIsland", CFrame.new(-13233, 332, -7626)}
			},
			["Beautiful Pirate"] = {
				IsBoss = true,
				Level = 1950,
				Position = CFrame.new(5370, 22, -89),
				Quest = {"DeepForestIsland2", CFrame.new(-12682, 391, -9901)}
			},
			["Cake Queen"] = {
				IsBoss = true,
				Level = 2175,
				Position = CFrame.new(-710, 382, -11150),
				Quest = {"IceCreamIslandQuest", CFrame.new(-818, 66, -10964)}
			},
			["Longma"] = {
				NoQuest = true,
				Position = CFrame.new(-10218, 333, -9444)
			}
		}
		
		Module.Shop = {
			{"Frags", {{"Race Reroll", {"BlackbeardReward", "Reroll", "2"}}, {"Reset Stats", {"BlackbeardReward", "Refund", "2"}}}},
			{"Fighting Style", {
				{"Buy Black Leg", {"BuyBlackLeg"}},
				{"Buy Electro", {"BuyElectro"}},
				{"Buy Fishman Karate", {"BuyFishmanKarate"}},
				{"Buy Dragon Claw", {"BlackbeardReward", "DragonClaw", "2"}},
				{"Buy Superhuman", {"BuySuperhuman"}},
				{"Buy Death Step", {"BuyDeathStep"}},
				{"Buy Sharkman Karate", {"BuySharkmanKarate"}},
				{"Buy Electric Claw", {"BuyElectricClaw"}},
				{"Buy Dragon Talon", {"BuyDragonTalon"}},
				{"Buy GodHuman", {"BuyGodhuman"}},
				{"Buy Sanguine Art", {"BuySanguineArt"}}
				-- {"Buy Divine Art", {"BuyDivineArt"}}
			}},
			{"Ability Teacher", {
				{"Buy Geppo", {"BuyHaki", "Geppo"}},
				{"Buy Buso", {"BuyHaki", "Buso"}},
				{"Buy Soru", {"BuyHaki", "Soru"}},
				{"Buy Ken", {"KenTalk", "Buy"}}
			}},
			{"Sword", {
				{"Buy Katana", {"BuyItem", "Katana"}},
				{"Buy Cutlass", {"BuyItem", "Cutlass"}},
				{"Buy Dual Katana", {"BuyItem", "Dual Katana"}},
				{"Buy Iron Mace", {"BuyItem", "Iron Mace"}},
				{"Buy Triple Katana", {"BuyItem", "Triple Katana"}},
				{"Buy Pipe", {"BuyItem", "Pipe"}},
				{"Buy Dual-Headed Blade", {"BuyItem", "Dual-Headed Blade"}},
				{"Buy Soul Cane", {"BuyItem", "Soul Cane"}},
				{"Buy Bisento", {"BuyItem", "Bisento"}}
			}},
			{"Gun", {
				{"Buy Musket", {"BuyItem", "Musket"}},
				{"Buy Slingshot", {"BuyItem", "Slingshot"}},
				{"Buy Flintlock", {"BuyItem", "Flintlock"}},
				{"Buy Refined Slingshot", {"BuyItem", "Refined Slingshot"}},
				{"Buy Dual Flintlock", {"BuyItem", "Dual Flintlock"}},
				{"Buy Cannon", {"BuyItem", "Cannon"}},
				{"Buy Kabucha", {"BlackbeardReward", "Slingshot", "2"}}
			}},
			{"Accessories", {
				{"Buy Black Cape", {"BuyItem", "Black Cape"}},
				{"Buy Swordsman Hat", {"BuyItem", "Swordsman Hat"}},
				{"Buy Tomoe Ring", {"BuyItem", "Tomoe Ring"}}
			}},
			{"Race", {{"Ghoul Race", {"Ectoplasm", "Change", 4}}, {"Cyborg Race", {"CyborgTrainer", "Buy"}}}}
		}
	end
	
	do
		Module.IsSuperBring = false;
		
		Module.RemoveCanTouch = 0;
		Module.AttackCooldown = 0;
		Module.PirateRaid = 0;
		
		Module.Webhooks = true;
		Module.JobIds = true;
		
		Module.Progress = {};
		Module.EnemyLocations = {};
		Module.SpawnLocations = {};
		
		Module.Cached = Cached;
		-- Module.Debounce = Debounce
		Module.IsAlive = IsAlive;
		Module.FireRemote = FireRemote;
		
		local SeaMaxVersion = ({26.61, 26.61, 26.61})[Module.GameData.Sea];
		Module.SuperFastAttack = Module.GameData.NumberVersion <= SeaMaxVersion;
	end
	
	Module.Signals = {} do
		local Signals = Module.Signals
		
		Signals.PossibleStaff = Signal.new()
		Signals.OptionChanged = Signal.new()
		Signals.EnemyAdded = Signal.new()
		Signals.EnemyDied = Signal.new()
		Signals.Notify = Signal.new()
		Signals.Error = Signal.new()

		Signals.Error:Connect(function(ErrorMessage)
			_ENV.loadedFarm = false
			_ENV.OnFarm = false
			
			local text = (`redz-Hub error [ {Settings.RunningOption or "Null"} ] {ErrorMessage}`)
			
			if _ENV.rz_error_message then
				_ENV.rz_error_message.Text ..= `\n\n{ text }`
				return nil
			end
			
			local Message = Instance.new("Message", workspace)
			_ENV.rz_error_message = Message
			Message.Text = text
		end)
	end
	
	Module.RunFunctions = {} do
		Module.RunFunctions.TweenModule = function()
			local module = {}
			module.__index = module
			
			local TweenService = game:GetService("TweenService")
			
			local tweens = {}
			local EasingStyle = Enum.EasingStyle.Linear
			
			function module.new(obj, time, prop, value)
				local self = setmetatable({}, module)
				
				self.tween = TweenService:Create(obj, TweenInfo.new(time, EasingStyle), { [prop] = value })
				self.tween:Play()
				self.value = value
				self.object = obj
				
				if tweens[obj] then
					tweens[obj]:destroy()
				end
				
				tweens[obj] = self
				return self
			end
			
			function module:destroy()
				self.tween:Pause()
				self.tween:Destroy()
				
				tweens[self.object] = nil
				setmetatable(self, nil)
			end
			
			function module:stopTween(obj)
				if obj and tweens[obj] then
					tweens[obj]:destroy()
				end
			end
			
			return module
		end
		
		Module.RunFunctions.Translator = function(Window, Translation)
			local MakeTab = Window.MakeTab
			
			Window.MakeTab = function(self, Configs)
				if Translation[ Configs[1] ] then
					Configs[1] = Translation[ Configs[1] ]
				end
				
				local Tab = MakeTab(self, Configs)
				local NewTab = {}
				
				function NewTab:AddSection(Name)
					return Tab:AddSection(Translation[Name] or Name)
				end
				
				function NewTab:AddButton(Configs)
					local Translator = Translation[ Configs[1] ]
					
					if Translator then
						Configs[1] = type(Translator) == "string" and Translator or Translator[1]
						Configs.Desc = type(Translator) ~= "string" and Translator[2]
					end
					
					return Tab:AddButton(Configs)
				end
				
				function NewTab:AddToggle(Configs)
					local Translator = Translation[ Configs[1] ]
					
					if Translator then
						Configs[1] = type(Translator) == "string" and Translator or Translator[1]
						Configs.Desc = type(Translator) ~= "string" and Translator[2]
					end
					
					return Tab:AddToggle(Configs)
				end
				
				function NewTab:AddSlider(Configs)
					local Translator = Translation[ Configs[1] ]
					
					if Translator then
						Configs[1] = type(Translator) == "string" and Translator or Translator[1]
						Configs.Desc = type(Translator) ~= "string" and Translator[2]
					end
					
					return Tab:AddSlider(Configs)
				end
				
				function NewTab:AddDropdown(Configs)
					local Translator = Translation[ Configs[1] ]
					
					if Translator then
						Configs[1] = type(Translator) == "string" and Translator or Translator[1]
						Configs.Desc = type(Translator) ~= "string" and Translator[2]
					end
					
					return Tab:AddDropdown(Configs)
				end
				
				function NewTab:AddTextBox(Configs)
					local Translator = Translation[ Configs[1] ]
					
					if Translator then
						Configs[1] = type(Translator) == "string" and Translator or Translator[1]
						Configs.Desc = type(Translator) ~= "string" and Translator[2]
					end
					
					return Tab:AddTextBox(Configs)
				end
				
				for i,v in pairs(Tab) do
					if not NewTab[i] then
						NewTab[i] = v
					end
				end
				
				return NewTab
			end
		end
		
		Module.RunFunctions.Quests = function(self, QuestsModule, getTasks)
			local MaxLvl = ({ {0, 700}, {700, 1500}, {1500, math.huge} })[self.Sea]
			local bl_Quests = {"BartiloQuest", "MarineQuest", "CitizenQuest"}
			
			for name, task in QuestsModule do
				if table.find(bl_Quests, name) then continue end
				
				for num, mission in task do
					local Level = mission.LevelReq
					if Level >= MaxLvl[1] and Level < MaxLvl[2] then
						local target, positions = getTasks(mission)
						table.insert(self.QuestList, {
							Name = name,
							Count = num,
							Enemy = { Name = target, Level = Level, Position = positions }
						})
					end
				end
			end
			
			table.sort(self.QuestList, function(v1, v2) return v1.Enemy.Level < v2.Enemy.Level end)
		end
		
		Module.RunFunctions.LibraryToggle = function(EnabledOptions, Options)
			return function(...)
				local Tab, Settings, Flag = ...
				
				Options[Flag] = Tab:AddToggle({
					Settings[1],																				 -- Name
					type(Settings[2]) ~= "string" and Settings[2],			 -- Default
					function(Value) EnabledOptions[Flag] = Value end,		-- Callback
					Flag,																								-- Flag
					Desc = (type(Settings[2]) == "string" and Settings[2]) or Settings[3]
				})
			end
		end
		
		Module.RunFunctions.FarmQueue = function(Options)
			local Success, ErrorMessage = pcall(function()
				local function GetQueue()
					for _, Option in Options do
						Settings.RunningOption = Option.Name
						local Method = Option.Function()
						
						if Method then
							if type(Method) == "string" then
								Settings.RunningMethod = Method
							end
							return Method
						end
					end
					
					Settings.RunningOption, Settings.RunningMethod = nil, nil
				end
				
				while task.wait(Settings.SmoothMode and 0.25 or 0) do
					if _ENV.teleporting then
						_ENV.OnFarm = true
					elseif Settings.FixOverflow then
						local Success, Response = pcall(GetQueue)
						
						_ENV.OnFarm = (not Success and _ENV.OnFarm) or Response
					else
						_ENV.OnFarm = if GetQueue() then true else false
					end
				end
			end)
			
			Module.Signals.Error:Fire(ErrorMessage)
		end
	end
	
	function Module.KillAura(Distance: number?, Name: string?): (nil)
		Distance = Distance or 500
		
		local EnemyList = Enemies:GetChildren()
		
		for i = 1, #EnemyList do
			local Enemy = EnemyList[i]
			local PrimaryPart = Enemy.PrimaryPart
			
			if (not Name or Enemy.Name == Name) and PrimaryPart and not Enemy:HasTag(KILLAURA_TAG) then
				if IsAlive(Enemy) and Player:DistanceFromCharacter(PrimaryPart.Position) < Distance then
					Enemy:AddTag(KILLAURA_TAG)
				end
			end
		end
	end
	
	function Module.IsBoss(Name: string): boolean
		return Module.Bosses[Name] and true or false
	end
	
	function Module.UseSkills(Target: any?, Skills: table?): (nil)
		if Player:DistanceFromCharacter(Target.Position) >= 60 then
			return nil
		end
		
		local Equipped = Player.Character and Player.Character:FindFirstChildOfClass("Tool")
		local MasteryRequirements = Module.Inventory.MasteryRequirements
		
		if Equipped then
			local Level = Equipped:GetAttribute("Level") or 0
			local Mastery = MasteryRequirements[Equipped.Name]
			
			if Mastery == nil and Equipped:FindFirstChild("Data") then
				local Success, Requirements = pcall(require, Equipped.Data)
				
				if Success and type(Requirements) == "table" then
					MasteryRequirements[Equipped.Name] = Requirements.Lvl or false
				else
					MasteryRequirements[Equipped.Name] = false
				end
			end
			
			for Skill, Enabled in Skills do
				if Mastery and not Mastery[Skill] then continue end
				if Mastery and Level < Mastery[Skill] then continue end
				
				local Debounce = Debounces.Skills[Skill]
				
				if Enabled and (not Debounce or (tick() - Debounce) >= HIDDEN_SETTINGS.SKILL_COOLDOWN) then
					VirtualInputManager:SendKeyEvent(true, Skill, false, game)
					VirtualInputManager:SendKeyEvent(false, Skill, false, game)
					Debounces.Skills[Skill] = tick()
				end
			end
		end
	end
	
	function Module.Rejoin(): (nil)
		if IsPrivateServer or #Players:GetPlayers() == 1 then
			TeleportService:Teleport(game.PlaceId, Player)
		else
			TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, Player)
		end
	end
	
	function Module.EnemySpawned(EnemyName)
		local Enemies = Module.Enemies
		return if type(EnemyName) == "table" then Enemies:GetClosest(EnemyName) else Enemies:GetEnemyByTag(EnemyName)
	end
	
	function Module:IsBlacklistedExecutor(): boolean
		return if IS_BLACKLISTED_EXECUTOR then true else false
	end
	
	function Module:TravelTo(Sea: number?): (nil)
		return FireRemote(`Travel{ self.GameData.SeasName[Sea] }`)
	end
	
	function Module:ServerHop(MaxPlayers: number?, Region: string?): (nil)
		self.RejoinBlocked = true -- bloqueia o Auto Rejoin
		MaxPlayers = math.min(MaxPlayers or self.SH_MaxPlrs or 8, 11)
		-- Region = Region or self.SH_Region or "Singapore"
		
		local ServerBrowser = ReplicatedStorage.__ServerBrowser; -- o evento que gerência tudo relacionado a "servidores"
		local InvokeServer = ServerBrowser.InvokeServer; -- armazena a função de "InvokeServer" para otimizar
		local MyJobId = game.JobId; -- armazena o JobId do server atual, também para otimizar o loop
		local CurrentPage = 1; -- a "página" atual de servidores ServerBrowser:InvokeServer(1. 2. 3...)
		local Blocked = false;
		
		local function forEachPage(Page)
			local Success, Servers = pcall(InvokeServer, ServerBrowser, Page) -- retorna a lista de servidores da página atual
			if not Success then return end
			if not Servers then Blocked = true return nil end -- se nenhum servidor for encontrado, ele retorna e quebra o loop
			
			local lowServerCount, lowServerId = MaxPlayers;
			
			for id, data in Servers do
				if id ~= MyJobId and data.Count <= lowServerCount then
					lowServerCount, lowServerId = data.Count, id
				end
			end
			
			if lowServerId then
				TeleportService:TeleportToPlaceInstance(game.PlaceId, lowServerId, Player)
			end
		end
		
		while not Blocked and CurrentPage < 150 do
			task.spawn(forEachPage, CurrentPage)
			CurrentPage += 1 -- avança para o próximo número da página
			task.wait()
		end
	end
	
	function Module.EquipTool(ToolName: string, ByType: boolean?): (nil)
		ByType = if not ToolName then true else ByType
		ToolName = ToolName or Settings.FarmTool
		
		if not IsAlive(Player.Character) then
			return nil
		end
		
		local Equipped = Cached.Equipped
		
		if Equipped and Equipped.Parent and Equipped[if ByType then "ToolTip" else "Name"] == ToolName then
			if Equipped:GetAttribute("Locks") then
				Equipped:SetAttribute("Locks", nil)
			end
			
			if Equipped.Parent == Player.Character then
				return nil
			elseif Equipped.Parent == Player.Backpack then
				Player.Character.Humanoid:EquipTool(Equipped)
				return nil
			end
		end
		
		if ToolName and not ByType then
			local BackpackTool = Player.Backpack:FindFirstChild(ToolName)
			
			if BackpackTool then
				Cached.Equipped = BackpackTool
				Player.Character.Humanoid:EquipTool(BackpackTool)
			end
		else
			for _, Tool in Player.Backpack:GetChildren() do
				if Tool:IsA("Tool") and Tool.ToolTip == ToolName then
					Cached.Equipped = Tool
					Player.Character.Humanoid:EquipTool(Tool)
					return nil
				end
			end
		end
	end
	
	function Module:BringEnemies(ToEnemy: Instance, SuperBring: boolean?, CustomCFrame: CFrame?, Distance: number?): (nil)
		if not IsAlive(ToEnemy) or not ToEnemy.PrimaryPart then
			return nil
		end
		
		pcall(sethiddenproperty, Player, "SimulationRadius", math.huge)
		
		if Distance or Settings.BringMobs then
			Module.IsSuperBring = if SuperBring then true else false
			
			local Name = ToEnemy.Name
			local Position = (Player.Character or Player.CharacterAdded:Wait()):GetPivot().Position
			local BringPositionTag = if SuperBring then "ALL_MOBS" else Name
			local Target = CustomCFrame or ToEnemy.PrimaryPart.CFrame
			local MaxDistance = Distance or Settings.BringDistance
			
			if not Cached.Bring[BringPositionTag] or (Target.Position - Cached.Bring[BringPositionTag].Position).Magnitude > 25 then
				Cached.Bring[BringPositionTag] = Target
			end
			
			local EnemyList = (not SuperBring and self.Enemies:GetTagged(Name)) or Enemies:GetChildren()
			
			for i = 1, #EnemyList do
				local Enemy = EnemyList[i]
				if not SuperBring and Enemy.Name ~= Name then continue end
				if Enemy.Parent ~= Enemies or Enemy:HasTag(BRING_TAG) then continue end
				if not Enemy:FindFirstChild("CharacterReady") then continue end
				
				local PrimaryPart = Enemy.PrimaryPart
				if IsAlive(Enemy) and PrimaryPart then
					if (Position - PrimaryPart.Position).Magnitude < MaxDistance then
						Enemy.Humanoid.WalkSpeed = 0
						Enemy.Humanoid.JumpPower = 0
						Enemy:AddTag(BRING_TAG)
					end
				end
			end
		else
			if not Cached.Bring[ToEnemy] then
				Cached.Bring[ToEnemy] = ToEnemy.PrimaryPart.CFrame
			end
			
			ToEnemy.PrimaryPart.CFrame = Cached.Bring[ToEnemy]
		end
	end
	
	function Module:GetRaidIsland(): Instance?
		if Cached.RaidIsland and Cached.RaidIsland:IsDescendantOf(Locations) then
			return Cached.RaidIsland
		end
		
		for i = 5, 1, -1 do
			local Name = "Island " .. i
			for _, Island in ipairs(Locations:GetChildren()) do
				if Island.Name == Name and Player:DistanceFromCharacter(Island.Position) < 3500 then
					Cached.RaidIsland = Island
					return Island
				end
			end
		end
	end
	
	function Module.GetProgress(...)
		local progressTag = ...
		local progressCache = Cached.Progress
		local entry = progressCache[progressTag]
		
		if entry and (tick() - entry.debounce) >= 2 then
			entry.result, entry.debounce = table.pack(FireRemote(...)), tick()
		elseif not entry then
			entry = { result = table.pack(FireRemote(...)), debounce = tick() }
			progressCache[progressTag] = entry
		end
		
		return unpack(entry.result)
	end
	
	function Module:RemoveVolcanoLava()
		local PrehistoricIsland = Map.PrehistoricIsland
		
		if PrehistoricIsland.Core:FindFirstChild("InteriorLava") then
			PrehistoricIsland.Core.InteriorLava:Destroy()
		end
		
		for _, Instance in PrehistoricIsland:GetDescendants() do
			if string.find(string.lower(Instance.Name), "lava") and Instance:IsA("BasePart") then
				Instance:Destroy()
			end
		end
	end
	
	function Module:RemoveBoatCollision(Boat)
		local Objects = Boat:GetDescendants()
		
		for i = 1, #Objects do
			local BasePart = Objects[i]
			if BasePart:IsA("BasePart") and BasePart.CanCollide then
				BasePart.CanCollide = false
			end
		end
	end
	
	function Module:GetRealFruitName(Fruit: Model?, ReturnsId: boolean?): string?
		if Fruit.Name ~= "Fruit " then
			return Fruit.Name
		end
		
		local CacheName = Cached.RealFruitsName
		local CacheId = Cached.RealFruitsId
		
		if not CacheName[Fruit] then
			CacheName[Fruit] = if ReturnsId then "???" else "Fruit [ ??? ]"
			
			local Model = Fruit:WaitForChild("Fruit", 9e9)
			local InstanceWithId = FastWait(2, Model, "Idle") or FastWait(1, Model, "Animation") or FastWait(1, Model, "Fruit")
			
			if InstanceWithId and (InstanceWithId:IsA("Animation") or InstanceWithId:IsA("MeshPart")) then
				local Property = if InstanceWithId:IsA("MeshPart") then "MeshId" else "AnimationId"
				local InstanceAssetId = InstanceWithId[Property]
				local RealName = self.FruitsId[InstanceAssetId]
				
				CacheId[Fruit] = InstanceAssetId
				
				if RealName and type(RealName) == "string" then
					CacheName[Fruit] = RealName
				end
			end
		end
		
		return if ReturnsId then CacheId[Fruit] else CacheName[Fruit]
	end
	
	Module.Chests = setmetatable({}, {
		__call = function(self, SelectedIsland)
			local CachedChest = self.Cached
			
			if CachedChest and not CachedChest:GetAttribute("IsDisabled") then
				if not SelectedIsland or CachedChest:IsDescendantOf(SelectedIsland) then
					return CachedChest
				end
			end
			
			if self.Debounce and (tick() - self.Debounce) < 0.5 then
				return nil
			end
			
			local Position = (Player.Character or Player.CharacterAdded:Wait()):GetPivot().Position
			local Chests = CollectionService:GetTagged("_ChestTagged")
			
			local Distance, Nearest = math.huge
			
			for i = 1, #Chests do
				local Chest = Chests[i]
				local Magnitude = (Chest:GetPivot().Position - Position).Magnitude
				
				if not SelectedIsland or Chest:IsDescendantOf(SelectedIsland) then
					if not Chest:GetAttribute("IsDisabled") and Magnitude < Distance then
						Distance, Nearest = Magnitude, Chest
					end
				end
			end
			
			self.Debounce = tick()
			self.Cached = Nearest
			return Nearest
		end
	})
	
	Module.Berry = setmetatable({}, {
		__call = function(self, BerryArray)
			local CachedBush = self.Cached
			
			if CachedBush and CachedBush:IsDescendantOf(Map) then
				for Tag, CFrame in pairs(CachedBush:GetAttributes()) do
					return CachedBush
				end
			end
			
			if self.Debounce and (tick() - self.Debounce) < 0.5 then
				return nil
			end
			
			local Position = (Player.Character or Player.CharacterAdded:Wait()):GetPivot().Position
			local BerryBush = CollectionService:GetTagged("BerryBush")
			
			local Distance, Nearest = math.huge
			
			for i = 1, #BerryBush do
				local Bush = BerryBush[i]
				
				for AttributeName, BerryName in pairs(Bush:GetAttributes()) do
					if not BerryArray or table.find(BerryArray, BerryName) then
						local Magnitude = (Bush.Parent:GetPivot().Position - Position).Magnitude
						
						if Magnitude < Distance then
							Nearest, Distance = Bush, Magnitude
						end
					end
				end
			end
			
			self.Debounce = tick()
			self.Cached = Nearest
			return Nearest
		end
	})

	Module.Enemies = (function()
		local EnemiesModule = CreateDictionary({
			"__CakePrince", "__PirateRaid", "__RaidBoss", "__TyrantSkies", "__Bones", "__Elite", "__Others", 
		}, {})
		
		local Signals = Module.Signals
		local SeaCastle = CFrame.new(-5556, 314, -2988)
		
		local TagsMobs = {
			__Elite = CreateDictionary({ "Deandre", "Diablo", "Urban" }, true),
			__Bones = CreateDictionary({ "Reborn Skeleton", "Living Zombie", "Demonic Soul", "Posessed Mummy" }, true),
			__CakePrince = CreateDictionary({ "Head Baker", "Baking Staff", "Cake Guard", "Cookie Crafter" }, true),
			__TyrantSkies = CreateDictionary({ "Sun-kissed Warrior", "Skull Slayer", "Isle Champion", "Serpent Hunter" }, true)
		}
		
		local Attachment = Instance.new("Attachment") do
			local AlignPosition = Instance.new("AlignPosition")
			AlignPosition.Mode = Enum.PositionAlignmentMode.OneAttachment
			AlignPosition.Position = Vector3.new(0, 20, 0)
			AlignPosition.Responsiveness = 200
			AlignPosition.MaxForce = math.huge
			AlignPosition.Parent = Attachment
			AlignPosition.Attachment0 = Attachment
		end
		
		local function New(list, NewEnemy)
			if table.find(list, NewEnemy) then return end
			
			local Humanoid = NewEnemy:WaitForChild("Humanoid")
			
			if Humanoid and Humanoid.Health > 0 then
				table.insert(list, NewEnemy)
				Humanoid.Died:Wait()
				local index = table.find(list, NewEnemy)
				if index then table.remove(list, index) end
			end
		end
		
		local function IsFromPiratesSea(Enemy)
			if not Enemy:WaitForChild("Humanoid") or Enemy.Humanoid.Health <= 0 then return end
			
			local HumanoidRootPart = Enemy:WaitForChild("HumanoidRootPart")
			
			if HumanoidRootPart and (Enemy.Name ~= "rip_indra True Form" and Enemy.Name ~= "Blank Buddy") then
				if (HumanoidRootPart.Position - SeaCastle.Position).Magnitude <= 750 then
					task.spawn(New, EnemiesModule.__PirateRaid, Enemy)
					Module.PirateRaid = tick()
				end
			end
		end
		
		local function NewEnemyAdded(Enemy)
			local EnemyName = Enemy.Name
			local Others = EnemiesModule.__Others
			
			Others[EnemyName] = Others[EnemyName] or {}
			task.spawn(New, Others[EnemyName], Enemy)
			
			if Module.GameData.Sea == 3 then
				task.spawn(IsFromPiratesSea, Enemy)
			end
			
			if Enemy:GetAttribute("RaidBoss") then
				task.spawn(New, EnemiesModule.__RaidBoss, Enemy)
			elseif EnemiesModule[`__{ EnemyName }`] then
				task.spawn(New, EnemiesModule[`__{ EnemyName }`], Enemy)
			else
				for Tag, Mobs in pairs(TagsMobs) do
					if Mobs[EnemyName] then
						task.spawn(New, EnemiesModule[Tag], Enemy)
						break
					end
				end
			end
		end
		
		function EnemiesModule.IsSpawned(EnemyName: string): boolean
			local Cached = Module.SpawnLocations[EnemyName]
			
			if Cached and Cached.Parent then
				return (Cached:GetAttribute("Active") or EnemiesModule:GetEnemyByTag(EnemyName)) and true or false
			end
			
			return EnemiesModule:GetEnemyByTag(EnemyName) and true or false
		end
		
		function EnemiesModule:GetTagged(TagName: string): table?
			return self[`__{TagName}`] or self.__Others[TagName]
		end
		
		function EnemiesModule:GetEnemyByTag(TagName: string): Model?
			local CachedEnemy = Cached.Enemies[TagName]
			
			if CachedEnemy and IsAlive(CachedEnemy) then
				return CachedEnemy
			end
			
			local Enemies = self:GetTagged(TagName)
			
			if Enemies and #Enemies > 0 then
				for i = 1, #Enemies do
					local Enemy = Enemies[i]
					
					if IsAlive(Enemy) then
						Cached.Enemies[TagName] = Enemy
						return Enemy
					end
				end
			end
		end
		
		function EnemiesModule:GetClosest(Enemies: table): Model?
			local SpecialTag = table.concat(Enemies, ".")
			local CachedEnemy = Cached.Enemies[SpecialTag]
			
			if CachedEnemy and IsAlive(CachedEnemy) then
				return CachedEnemy
			end
			
			local Distance, Nearest = math.huge
			
			for i = 1, #Enemies do
				local Enemy = self:GetClosestByTag(Enemies[i])
				local Magnitude = Enemy and Player:DistanceFromCharacter(Enemy.PrimaryPart.Position)
				
				if Enemy and Magnitude <= Distance then
					Distance, Nearest = Magnitude, Enemy
				end
			end
			
			if Nearest then
				Cached.Enemies[SpecialTag] = Nearest
				return Nearest
			end
		end
		
		function EnemiesModule:GetClosestByTag(TagName: string): Model?
			local CachedEnemy = Cached.Enemies[TagName]
			
			if CachedEnemy and IsAlive(CachedEnemy) then
				return CachedEnemy
			end
			
			local Enemies = self:GetTagged(TagName)
			
			if Enemies and #Enemies > 0 then
				local Distance, Nearest = math.huge
				
				local Position = (Player.Character or Player.CharacterAdded()):GetPivot().Position
				
				for i = 1, #Enemies do
					local Enemy = Enemies[i]
					local PrimaryPart = Enemy.PrimaryPart
					
					if PrimaryPart and IsAlive(Enemy) then
						local Magnitude = (Position - PrimaryPart.Position).Magnitude
						
						if Magnitude <= 15 then
							Cached.Enemies[TagName] = Enemy
							return Enemy
						elseif Magnitude <= Distance then
							Distance, Nearest = Magnitude, Enemy
						end
					end
				end
				
				if Nearest then
					Cached.Enemies[TagName] = Nearest
					return Nearest
				end
			end
		end
		
		function EnemiesModule:CreateNewTag(Tag: string, Enemies: table): table?
			local NewTag = {}
			self[`__{Tag}`] = NewTag
			
			for i = 1, #Enemies do
				self[`__{Enemies[i]}`] = NewTag
				local Others = self.__Others[ Enemies[i] ]
				
				if Others then
					for i = 1, #Others do
						task.spawm(newEnemy, NewTag, Others[i])
					end
				end
			end
			
			return NewTag
		end
		
		local function Bring(Enemy)
			local RootPart = Enemy:WaitForChild("HumanoidRootPart")
			local Humanoid = Enemy:WaitForChild("Humanoid")
			local EnemyName = Enemy.Name
			
			local CloneAttachment = Attachment:Clone()
			local AlignPosition = CloneAttachment.AlignPosition
			CloneAttachment.Parent = RootPart
			
			while Enemy and Enemy.Parent == Enemies and Enemy:HasTag(BRING_TAG) do
				if not Humanoid or Humanoid.Health <= 0 then break end
				if not RootPart or RootPart.Parent ~= Enemy then break end
				
				local Target = Cached.Bring[if Module.IsSuperBring then "ALL_MOBS" else EnemyName]
				
				if Target and (Target.Position - RootPart.Position).Magnitude <= Settings.BringDistance then
					if AlignPosition.Position ~= Target.Position then
						AlignPosition.Position = Target.Position
					end
				else
					break
				end;task.wait()
			end
			
			if Enemy and Enemy:HasTag(BRING_TAG) then Enemy:RemoveTag(BRING_TAG) end
			if CloneAttachment then CloneAttachment:Destroy() end
		end
		
		local function KillAura(Enemy)
			local Humanoid = Enemy:FindFirstChild("Humanoid")
			local RootPart = Enemy:FindFirstChild("HumanoidRootPart")
			
			pcall(sethiddenproperty, Player, "SimulationRadius", math.huge)
			
			if Humanoid and RootPart then
				RootPart.CanCollide = false
				RootPart.Size = Vector3.new(60, 60, 60)
				Humanoid:ChangeState(15)
				Humanoid.Health = 0
				task.wait()
				Enemy:RemoveTag(KILLAURA_TAG)
			end
		end
		
		for _, Enemy in CollectionService:GetTagged("BasicMob") do NewEnemyAdded(Enemy) end
		table.insert(Connections, CollectionService:GetInstanceAddedSignal("BasicMob"):Connect(NewEnemyAdded))
		
		table.insert(Connections, CollectionService:GetInstanceAddedSignal(KILLAURA_TAG):Connect(KillAura))
		table.insert(Connections, CollectionService:GetInstanceAddedSignal(BRING_TAG):Connect(Bring))
		
		return EnemiesModule
	end)()
	
	Module.Inventory = (function()
		local Inventory = {
			Unlocked = setmetatable({}, { __index = function() return false end }),
			Mastery = setmetatable({}, { __index = function() return 0 end }),
			Count = setmetatable({}, { __index = function() return 0 end }),
			MasteryRequirements = {},
			Items = {},
		}
		
		function Inventory:UpdateItem(item)
			if type(item) == "table" then
				if item.Type == "Wear" then
					item.Type = "Accessory"
				end
				
				local Name = item.Name
				
				self.Items[Name] = item
				
				if not self.Unlocked[Name] then self.Unlocked[Name] = true end
				if item.Count then self.Count[Name] = item.Count end
				if item.Mastery then self.Mastery[Name] = item.Mastery end
				if item.MasteryRequirements then self.MasteryRequirements[Name] = item.MasteryRequirements end
			end
		end
		
		function Inventory:RemoveItem(ItemName)
			if type(ItemName) == "string" then
				self.Unlocked[ItemName] = nil
				self.Mastery[ItemName] = nil
				self.Count[ItemName] = nil
				self.Items[ItemName] = nil
			end
		end
		
		local function OnClientEvent(Method, ...)
			if Method == "ItemChanged" then
				Inventory:UpdateItem(...)
			elseif Method == "ItemAdded" then
				Inventory:UpdateItem(...)
			elseif Method == "ItemRemoved" then
				Inventory:RemoveItem(...)
			elseif Method == "Notify" then
				Module.Signals.Notify:Fire(...)
			end
		end
		
		task.spawn(function()
			table.insert(Connections, CommE.OnClientEvent:Connect(OnClientEvent))
			local InventoryItems = nil;
			
			repeat
				task.wait(1)
				InventoryItems = FireRemote("getInventory")
			until type(InventoryItems) == "table"
			
			for index = 1, #InventoryItems do
				Inventory:UpdateItem(InventoryItems[index])
			end
		end)
		
		return Inventory
	end)()
	
	Module.FastAttack = (function()
		local FastAttack = {
			Distance = 50,
			attackMobs = true,
			attackPlayers = true,
			Equipped = nil,
			Debounce = 0,
			ComboDebounce = 0,
			ShootDebounce = 0,
			M1Combo = 0,
			
			Overheat = {
				["Dragonstorm"] = {
					MaxOverheat = 3,
					Cooldown = 0,
					TotalOverheat = 0,
					Distance = 400,
					Shooting = false
				}
			},
			ShootsPerTarget = {
				["Dual Flintlock"] = 2
			},
			SpecialShoots = {
				["Skull Guitar"] = "TAP",
				["Bazooka"] = "Position",
				["Cannon"] = "Position",
				["Dragonstorm"] = "Overheat"
			},
			NormalClickFruits = {
				["Light-Light"] = true,
				["Ice-Ice"] = true
			}
		}
		
		local RE_RegisterAttack: RemoteEvent = Net:WaitForChild("RE/RegisterAttack")
		local RE_ShootGunEvent: RemoteEvent = Net:WaitForChild("RE/ShootGunEvent")
		local RE_RegisterHit: RemoteEvent = Net:WaitForChild("RE/RegisterHit")
		local Events: Folder = ReplicatedStorage:WaitForChild("Events")
		
		local SUCCESS_FLAGS, COMBAT_REMOTE_THREAD = pcall(function()
			return require(Modules.Flags).COMBAT_REMOTE_THREAD or false
		end)
		
		local SUCCESS_SHOOT, SHOOT_FUNCTION = pcall(function()
			return getupvalue(require(ReplicatedStorage.Controllers.CombatController).Attack, 9)
		end)
		
		local HIT_FUNCTION; task.defer(function()
			local PlayerScripts = Player:WaitForChild("PlayerScripts")
			local LocalScript = PlayerScripts:FindFirstChildOfClass("LocalScript")
			
			while not LocalScript do
				Player.PlayerScripts.ChildAdded:Wait()
				LocalScript = PlayerScripts:FindFirstChildOfClass("LocalScript")
			end
			
			if getsenv then
				local Success, ScriptEnv = pcall(getsenv, LocalScript)
				
				if Success and ScriptEnv then
					HIT_FUNCTION = ScriptEnv._G.SendHitsToServer
				end
			end
		end)
		
		FastAttack.ShootsFunctions = {
			["Skull Guitar"] = function(self: FastAttack, Equipped: Tool, Position: Vector3): (nil)
				Equipped.RemoteEvent:FireServer("TAP", Position) -- Events.ShootSoulGuitar:Invoke(Position)
			end
		}
		
		local CurrentBladeHits = {};
		local MyRootPartPosition = nil;
		local NoAttackBelowTool = nil;
		local NoAttackBelowDebounce = 0;
		local BelowHealthPercent = 0;
		
		local function ExpandsHitBox(Enemies: { table }): (nil)
			for i = 1, #Enemies do
				Enemies[i][2].Size = Vector3.one * 50
				Enemies[i][2].Transparency = 1
			end
		end
		
		local function CheckStun(ToolTip: string, Character: Character, Humanoid: Humanoid): boolean
			-- local Stun = Character:FindFirstChild("Stun")
			-- local Busy = Character:FindFirstChild("Busy")
			
			if Humanoid.Sit and (ToolTip == "Sword" or ToolTip == "Melee" or ToolTip == "Gun") then
				return false
			-- elseif Stun and Stun.Value > 0 then {{ or Busy and Busy.Value }}
			--	 return false
			end
			
			return true
		end
		
		local function NewBladeHit(RootPart: BasePart, Character: Model): (nil)
			table.insert(CurrentBladeHits, { Character, RootPart })
		end
		
		local function GetMaxHits(Character)
			if Character:FindFirstChild("HumanoidRootPart") and Character.HumanoidRootPart:FindFirstChild("Buddha") then
				return 10
			end
			return 1
		end
		
		local function ProcessSeaEventsHits(Distance)
			for _, SeaBeast in SeaBeasts:GetChildren() do
				local BasePart = SeaBeast:FindFirstChildOfClass("MeshPart")
				
				if IsAlive(SeaBeast) and BasePart and (MyRootPartPosition - BasePart.Position).Magnitude < Distance then
					NewBladeHit(BasePart, SeaBeast)
				end
			end
			
			for _, Boat in Enemies:GetChildren() do
				if not Boat:GetAttribute("IsBoat") then continue end
				local BasePart = Boat:FindFirstChildOfClass("MeshPart")
				
				if IsAlive(Boat) and BasePart and (MyRootPartPosition - BasePart.Position).Magnitude < Distance then
					NewBladeHit(BasePart, Boat)
				end
			end
		end
		
		local function CanChangeGunTarget(Target, Enemy)
			if Enemy.Parent == SeaBeasts then
				return true
			elseif Target.Parent ~= SeaBeasts and Enemy:GetAttribute("IsBoat") then
				return true
			end
			
			return false
		end
		
		local function ConvertToGunHits()
			local Target, Hitbox;
			
			for index = 1, #CurrentBladeHits do
				local Hit = CurrentBladeHits[index]
				
				if not Target or CanChangeGunTarget(Target, Hit[1]) then
					Hitbox, Target = Hit[2], Hit[1];
				end
			end
			
			CurrentBladeHits = { Hitbox, math.random() }
			return Hitbox.Position, Hitbox;
		end
		
		local function ProcessHits(List: Folder, Equipped: Tool, Distance: number): (nil)
			local MyCharacter = Player.Character;
			local Targets = List:GetChildren();
			local MaxHits = GetMaxHits(MyCharacter) + 1;
			
			for i = 1, #Targets do
				if #CurrentBladeHits >= MaxHits then break end
				
				local Character = Targets[i]
				if Character == MyCharacter or Character:GetAttribute("IsBoat") or not IsAlive(Character) then continue end
				local RootPart = Character.PrimaryPart
				
				if (tick() - NoAttackBelowDebounce) <= 1 then
					local Humanoid = Character.Humanoid
					
					if Humanoid.Health / Humanoid.MaxHealth * 100 <= BelowHealthPercent then
						continue
					end
				end
				
				if RootPart and (Character.Parent ~= Characters or CheckPlayerAlly(Character)) then
					local Hitbox = GetRandomHitboxLimb(Character) or RootPart
					
					if Hitbox and (MyRootPartPosition - RootPart.Position).Magnitude <= Distance then
						NewBladeHit(Hitbox, Character)
					end
				end
			end
		end
		
		function FastAttack:DontAttackBelowPercent(Percent: number): boolean
			if SUCCESS_FLAGS and not COMBAT_REMOTE_THREAD or SUCCESS_FLAGS and COMBAT_REMOTE_THREAD and HIT_FUNCTION then
				BelowHealthPercent = Percent
				NoAttackBelowDebounce = tick()
				
				return true
			end
			
			return false
		end
		
		function FastAttack:UpdateBladeHits(Distance: number?, Anything: boolean?, SeasEvents: boolean?): (nil)
			Distance = Distance or self.Distance;
			CurrentBladeHits = {};
			
			if Anything or self.attackMobs then
				ProcessHits(Enemies, self.Equipped, Distance)
			end
			if Anything or self.attackPlayers then
				ProcessHits(Characters, self.Equipped, Distance)
			end
			if SeasEvents then
				ProcessSeaEventsHits(Distance, self.Equipped)
			end
		end
		
		function FastAttack:ShootInTarget(TargetPosition: Vector3): (nil)
			local Equipped = IsAlive(Player.Character) and Player.Character:FindFirstChildOfClass("Tool")
			
			if Equipped and Equipped.ToolTip == "Gun" then
				if Equipped:FindFirstChild("Cooldown") and (tick() - self.ShootDebounce) >= Equipped.Cooldown.Value then
					if self.ShootsFunctions[Equipped.Name] then
						return self.ShootsFunctions[Equipped.Name](self, Equipped, TargetPosition)
					end
					
					if SUCCESS_SHOOT and SHOOT_FUNCTION then
						local ShootType = self.SpecialShoots[Equipped.Name] or "Normal"
						
						if ShootType == "Position" or (ShootType == "TAP" and Equipped:FindFirstChild("RemoteEvent")) then
							Equipped:SetAttribute("LocalTotalShots", (Equipped:GetAttribute("LocalTotalShots") or 0) + 1)
							GunValidator:FireServer(self:GetValidator2())
							
							if ShootType == "TAP" then
								Equipped.RemoteEvent:FireServer("TAP", TargetPosition)
							else
								RE_ShootGunEvent:FireServer(TargetPosition)
							end
							
							self.ShootDebounce = tick()
						end
					else
						VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1);task.wait(0.05)
						VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1);task.wait(0.05)
						self.ShootDebounce = tick()
					end
				end
			end
		end
		
		function FastAttack:GetClosestEnemy(Distance: number?): (nil)
			self:UpdateBladeHits(Distance, true)
			
			local Distance, Closest = math.huge
			
			for i = 1, #CurrentBladeHits do
				local Magnitude = (MyRootPartPosition - CurrentBladeHits[i][2].Position).Magnitude
				
				if Magnitude <= Distance then
					Distance, Closest = Magnitude, CurrentBladeHits[i][2]
				end
			end
			
			return Closest
		end
		
		function FastAttack:GetCombo(): number
			local Combo = if tick() - self.ComboDebounce <= 0.4 then self.M1Combo else 0
			Combo = if Combo >= 4 then 1 else Combo + 1
			
			self.ComboDebounce = tick()
			self.M1Combo = Combo
			
			return Combo
		end
		
		function FastAttack:UseFruitM1(Character: Character, Equipped: Tool, Combo: number): (nil)
			local MyPosition = Character.Humanoid.RootPart.Position
			local _Enemies = Enemies:GetChildren()
			
			for i = 1, #_Enemies do
				local Enemy = _Enemies[i]
				local RootPart = IsAlive(Enemy) and Enemy.PrimaryPart
				
				if RootPart and (RootPart.Position - MyPosition).Magnitude <= 50 then
					Equipped.LeftClickRemote:FireServer((RootPart.Position - MyPosition).Unit, Combo)
				end
			end
		end
		
		function FastAttack:SuperFastAttack(EnemyHitBox, BladeHits, Cooldown)
			if Module.SuperFastAttack and Settings.FastAttack then
				local Enemy = EnemyHitBox.Parent
				local Times = if Enemy:GetAttribute("IsBoss") then 25 elseif Enemy:GetAttribute("RaidBoss") then 40 else 6
				
				self.Debounce = tick() + 9e9;
				local Overheat = 0;
				
				table.insert(BladeHits, { EnemyHitBox.Parent, EnemyHitBox })
				table.insert(BladeHits, math.random())
				
				while Overheat <= 0.4 do
					for i = 1, Times do
						RE_RegisterAttack:FireServer(self:GetCombo())
						HIT_FUNCTION(EnemyHitBox, BladeHits)
					end
					Overheat += task.wait(if Times > 10 then 0.07 else 0)
				end
				
				self.Debounce = 0;
				return true;
			end
		end
		
		function FastAttack:UseNormalClick(Cooldown: number): (nil)
			self:UpdateBladeHits()
			
			if #CurrentBladeHits > 0 then
				local PrimaryRootPart = table.remove(CurrentBladeHits)[2]
				
				if SUCCESS_FLAGS and COMBAT_REMOTE_THREAD and HIT_FUNCTION then
					if not self:SuperFastAttack(PrimaryRootPart, CurrentBladeHits, Cooldown) then
						RE_RegisterAttack:FireServer(Cooldown)
						HIT_FUNCTION(PrimaryRootPart, CurrentBladeHits)
					end
				elseif SUCCESS_FLAGS and not COMBAT_REMOTE_THREAD then
					RE_RegisterAttack:FireServer(Cooldown)
					RE_RegisterHit:FireServer(PrimaryRootPart, CurrentBladeHits)
				else
					table.insert(CurrentBladeHits, { Enemy, PrimaryRootPart })
					ExpandsHitBox(CurrentBladeHits)
					
					VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1);task.wait(0.05)
					VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
				end
			end
		end
		
		function FastAttack:GetValidator2()
			local v1 = getupvalue(SHOOT_FUNCTION, 15) -- v40, 15
			local v2 = getupvalue(SHOOT_FUNCTION, 13) -- v41, 13
			local v3 = getupvalue(SHOOT_FUNCTION, 16) -- v42, 16
			local v4 = getupvalue(SHOOT_FUNCTION, 17) -- v43, 17
			local v5 = getupvalue(SHOOT_FUNCTION, 14) -- v44, 14
			local v6 = getupvalue(SHOOT_FUNCTION, 12) -- v45, 12
			local v7 = getupvalue(SHOOT_FUNCTION, 18) -- v46, 18
			
			local v8 = v6 * v2									-- v133
			local v9 = (v5 * v2 + v6 * v1) % v3 -- v134
			
			v9 = (v9 * v3 + v8) % v4
			v5 = math.floor(v9 / v3)
			v6 = v9 - v5 * v3
			v7 = v7 + 1
			
			setupvalue(SHOOT_FUNCTION, 15, v1) -- v40, 15
			setupvalue(SHOOT_FUNCTION, 13, v2) -- v41, 13
			setupvalue(SHOOT_FUNCTION, 16, v3) -- v42, 16
			setupvalue(SHOOT_FUNCTION, 17, v4) -- v43, 17
			setupvalue(SHOOT_FUNCTION, 14, v5) -- v44, 14
			setupvalue(SHOOT_FUNCTION, 12, v6) -- v45, 12
			setupvalue(SHOOT_FUNCTION, 18, v7) -- v46, 18
			
			return math.floor(v9 / v4 * 16777215), v7
		end
		
		function FastAttack:UseGunShoot(Character, Equipped)
			if not Equipped.Enabled then return end
			
			local ShootType = self.SpecialShoots[Equipped.Name] or "Normal"
			
			if ShootType == "Normal" or ShootType == "Overheat" then
				local Distance = if ShootType == "Overheat" then self.Overheat[Equipped.Name].Distance else 200
				self:UpdateBladeHits(Distance, false, true)
				
				if #CurrentBladeHits == 0 then
					return nil
				end
				
				local Position, PrimaryPart = ConvertToGunHits()
				local PrimaryTarget = PrimaryPart.Parent
				
				if ShootType == "Overheat" then
					self.Debounce = tick() + 9e9
					
					while PrimaryTarget.Parent and IsAlive(PrimaryTarget) and Equipped and Equipped.Parent == Player.Character do
						if PrimaryPart.Parent ~= PrimaryTarget or DistanceFromCharacter(PrimaryPart) > Distance then
							break
						end
						
						Equipped:SetAttribute("LocalTotalShots", (Equipped:GetAttribute("LocalTotalShots") or 0) + 1)
						GunValidator:FireServer(self:GetValidator2())
						RE_ShootGunEvent:FireServer(Position, CurrentBladeHits)
						task.wait()
					end
					
					self.Debounce = 0
				elseif PrimaryTarget then
					Equipped:SetAttribute("LocalTotalShots", (Equipped:GetAttribute("LocalTotalShots") or 0) + 1)
					GunValidator:FireServer(self:GetValidator2())
					
					for i = 1, (self.ShootsPerTarget[Equipped.Name] or 1) do
						RE_ShootGunEvent:FireServer(Position, CurrentBladeHits)
					end
				end
			elseif ShootType == "Position" or (ShootType == "TAP" and Equipped:FindFirstChild("RemoteEvent")) then
				local Target = self:GetClosestEnemy(200)
				
				if Target then
					if self.ShootsFunctions[Equipped.Name] then
						return self.ShootsFunctions[Equipped.Name](self, Equipped, Target.Position)
					end
					
					Equipped:SetAttribute("LocalTotalShots", (Equipped:GetAttribute("LocalTotalShots") or 0) + 1)
					GunValidator:FireServer(self:GetValidator2())
					
					if ShootType == "TAP" then
						Equipped.RemoteEvent:FireServer("TAP", Target.Position)
					else
						RE_ShootGunEvent:FireServer(Target.Position)
					end
				end
			end
		end
		
		table.insert(Connections, Stepped:Connect(function()
			if not Settings.AutoClick or (tick() - Module.AttackCooldown) <= 1 then return end
			if not IsAlive(Player.Character) then return end
			
			local self = FastAttack;
			local Character = Player.Character;
			local Humanoid = Character.Humanoid;
			
			if not Humanoid.RootPart then return end
			
			local Equipped = Character:FindFirstChildOfClass("Tool")
			local ToolTip = Equipped and Equipped.ToolTip
			
			if not Equipped or (ToolTip ~= "Gun" and ToolTip ~= "Melee" and ToolTip ~= "Blox Fruit" and ToolTip ~= "Sword") then
				return nil
			end
			
			local Cooldown = Equipped:FindFirstChild("Cooldown") and Equipped.Cooldown.Value or 0.3;
			
			if (tick() - self.Debounce) >= Cooldown and CheckStun(ToolTip, Character, Humanoid) then
				local Combo = self:GetCombo();
				if Combo >= 4 then Cooldown += 0.05 end;
				
				self.Equipped = Equipped;
				self.Debounce = if Combo >= 4 and ToolTip ~= "Gun" then tick() + 0.05 else tick();
				MyRootPartPosition = Character.Humanoid.RootPart.Position;
				
				if ToolTip == "Blox Fruit" and not self.NormalClickFruits[Equipped.Name] then
					if Equipped:FindFirstChild("LeftClickRemote") then
						self:UseFruitM1(Character, Equipped, Combo)
					end
				elseif ToolTip == "Gun" then
					if SUCCESS_SHOOT and SHOOT_FUNCTION and (Settings.AutoShoot or Settings.dStormSea) then
						self:UseGunShoot(Character, Equipped)
					end
				else
					self:UseNormalClick(Cooldown)
				end
			end
		end))
		
		return FastAttack
	end)()
	
	Module.RaidList = (function()
		local Success, RaidModule = pcall(require, ReplicatedStorage:WaitForChild("Raids"))
		
		if not Success or type(RaidModule) ~= "table" then
			return {
				"Phoenix", "Dough", "Flame", "Ice", "Quake", "Light";
				"Dark", "Spider", "Rumble", "Magma", "Buddha", "Sand";
			}
		end
		
		local AdvancedRaids = RaidModule.advancedRaids or {}
		local NormalRaids = RaidModule.raids or {}
		local RaidList = {}
		
		for i = 1, #AdvancedRaids do table.insert(RaidList, AdvancedRaids[i]) end
		for i = 1, #NormalRaids do table.insert(RaidList, NormalRaids[i]) end
		
		return RaidList
	end)()
	
	Module.Tween = (function()
		local BodyVelocity = Instance.new("BodyVelocity")
		BodyVelocity.Velocity = Vector3.zero
		BodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
		BodyVelocity.P = 1000
		
		if _ENV.tween_bodyvelocity then
			_ENV.tween_bodyvelocity:Destroy()
		end
		
		_ENV.tween_bodyvelocity = BodyVelocity
		
		local IsCustomTag = false
		
		local BaseParts, CanCollideObjects, CanTouchObjects = {}, {}, {} do
			local function AddObjectToBaseParts(Object)
				if Object:IsA("BasePart") and (Object.CanCollide or Object.CanTouch) then
					table.insert(BaseParts, Object)
					
					if Object.CanCollide then CanCollideObjects[Object] = true end
					if Object.CanTouch then CanTouchObjects[Object] = true end
				end
			end
			
			local function RemoveObjectsFromBaseParts(BasePart)
				local index = table.find(BaseParts, BasePart)
				
				if index then
					table.remove(BaseParts, index)
				end
			end
			
			local function NewCharacter(Character)
				table.clear(BaseParts)
				
				for _, Object in ipairs(Character:GetDescendants()) do AddObjectToBaseParts(Object) end
				Character.DescendantAdded:Connect(AddObjectToBaseParts)
				Character.DescendantRemoving:Connect(RemoveObjectsFromBaseParts)
				
				Character:WaitForChild("Humanoid", 9e9).Died:Wait()
				table.clear(BaseParts)
			end
			
			table.insert(Connections, Player.CharacterAdded:Connect(NewCharacter))
			task.spawn(NewCharacter, Player.Character)
		end
		
		local function NoClipOnStepped(Character)
			if not IsAlive(Character) then return end
			
			if not IsCustomTag and _ENV.OnFarm then
				IsCustomTag = true
			end
			
			if _ENV.OnFarm and not Player:HasTag("Teleporting") then
				Player:AddTag("Teleporting")
				IsCustomTag = true
			elseif IsCustomTag and not _ENV.OnFarm and Player:HasTag("Teleporting") then
				Player:RemoveTag("Teleporting")
				IsCustomTag = false
			end
			
			if _ENV.OnFarm then
				for i = 1, #BaseParts do
					local BasePart = BaseParts[i]
					local CanTouchValue = if (tick() - Module.RemoveCanTouch) <= 1 then false else true
					
					if CanTouchObjects[BasePart] and BasePart.CanTouch ~= CanTouchValue then
						BasePart.CanTouch = CanTouchValue
					end
					if CanCollideObjects[BasePart] and BasePart.CanCollide then
						BasePart.CanCollide = false
					end
				end
			elseif Character.PrimaryPart and (not Character.PrimaryPart.CanCollide or not Character.PrimaryPart.CanTouch) then
				for i = 1, #BaseParts do
					local BasePart = BaseParts[i]
					
					if CanCollideObjects[BasePart] then
						BasePart.CanCollide = true
					end
					if CanTouchObjects[BasePart] then
						BasePart.CanTouch = true
					end
				end
			end
		end
		
		local function UpdateVelocityOnStepped(Character)
			local BasePart = Character:FindFirstChild("UpperTorso")
			local Humanoid = Character:FindFirstChild("Humanoid")
			local BodyVelocity = _ENV.tween_bodyvelocity
			
			if _ENV.OnFarm and BasePart and Humanoid and Humanoid.Health > 0 then
				if BodyVelocity.Parent ~= BasePart then
					BodyVelocity.Parent = BasePart
				end
			else
				if BodyVelocity.Parent then
					BodyVelocity.Parent = nil
				end
			end
			
			if BodyVelocity.Velocity ~= Vector3.zero and (not Humanoid or not Humanoid.SeatPart or not _ENV.OnFarm) then
				BodyVelocity.Velocity = Vector3.zero
			end
		end
		
		table.insert(Connections, Stepped:Connect(function()
			local Character = Player.Character
			if IsAlive(Character) then
				UpdateVelocityOnStepped(Character)
				NoClipOnStepped(Character)
			end
		end))
		
		return BodyVelocity
	end)()
	
	Module.Hooking = (function()
		local Hooking = {
			Skills = CreateDictionary({ "Z", "X", "C", "V", "F" }, true)
		}
		
		local Enabled = _ENV.rz_EnabledOptions;
		local ClosestEnemie = nil;
		
		local DisableUpdateClosest = 0;
		local UpdateClosestsDebounce = 0;
		local CharacterBasePartName = "RightLowerArm";
		
		local function _GetCurrentTarget(Tag: string): any?
			if (tick() - DisableUpdateClosest) <= 2 or _ENV[Tag] then
				return ClosestEnemie
			end
		end
    
    local function UpdateClosests()
      local SmoothUpdateCooldown = if Settings.SmoothMode then 0.5 else 0.25
      local time = tick()
      
      if ClosestEnemie and not ClosestEnemie.Parent then
      	ClosestEnemie.Parent = nil
      end
      
      if (time - DisableUpdateClosest) <= 2 or (time - UpdateClosestsDebounce) <= SmoothUpdateCooldown then
        return nil
      else
        UpdateClosestsDebounce = time
      end
      
      local MyCharacter = Player.Character
      local Equipped = MyCharacter and MyCharacter:FindFirstChildOfClass("Tool")
      
      if Equipped and Equipped.ToolTip and MyCharacter.Humanoid.RootPart then
        local ClosestDistance = if Equipped.ToolTip == "Gun" then 180 else 900
        
        local MyPosition = MyCharacter.Humanoid.RootPart.Position
        local _Characters = Characters:GetChildren()
        local _Enemies = Enemies:GetChildren()
        
        for i = 1, #_Characters do
          local Character = _Characters[i]
          if Character == MyCharacter or not CheckPlayerAlly(Character) then continue end
          local Humanoid = Character:FindFirstChildOfClass("Humanoid")
          local Hitbox = GetRandomHitboxLimb(Character)
					
					if Hitbox and IsAlive(_, Humanoid) and Humanoid.RootPart then
						local Magnitude = (Humanoid.RootPart.Position - MyPosition).Magnitude
						
						if Magnitude <= ClosestDistance then
							ClosestEnemie, ClosestDistance = Hitbox, Magnitude
						end
          end
        end
        
				for i = 1, (if Settings.NoAimMobs then 0 else #_Enemies) do
          local Mob = _Enemies[i]
          local Humanoid = Mob:FindFirstChildOfClass("Humanoid")
          local Hitbox = GetRandomHitboxLimb(Mob)
					
					if Hitbox and IsAlive(_, Humanoid) and Humanoid.RootPart then
						local Magnitude = (Humanoid.RootPart.Position - MyPosition).Magnitude
						
						if Magnitude <= ClosestDistance then
							ClosestEnemie, ClosestDistance = Hitbox, Magnitude
						end
					end
				end
			end
		end
		
		local function hook_newindex()
			if _ENV.rz_enabled_bypass or not HIDDEN_SETTINGS.WALKSPEED_BYPASS_ENABLED then return end
			_ENV.rz_enabled_bypass = true
			
			local old_newindex;
			old_newindex = hookmetamethod(Player, "__newindex", function(self, index, value)
				if index == "WalkSpeed" and self.Name == "Humanoid" then
					return old_newindex(self, "WalkSpeed", _ENV.WalkSpeedBypass or value)
				else
					return old_newindex(self, index, value)
				end
			end)
		end
		
		local function hook_namecall()
			if not HIDDEN_SETTINGS.SILENT_AIM_ENABLED then return end
			if _ENV.rz_original_namecall then return end
			
			table.insert(Connections, Stepped:Connect(UpdateClosests))
			
			local Events = {
				["RE/ShootGunEvent"] = function(...)
					local Position, Enemies = ...
					
					if typeof(Position) == "Vector3" and type(Enemies) == "table" and #Enemies ~= 0 then
						local ClosestMob = _GetCurrentTarget("AimBot_Gun")
						
						if ClosestMob then
							return ClosestMob.Position, { ClosestMob }
						end
					end
					
					return ...
				end,
				["RemoteEvent"] = function(...)
					local param1, param2 = ...
					
					if typeof(param1) == "Vector3" and not param2 then
						local Target = _GetCurrentTarget("AimBot_Skills")
						
						if Target then
							return Target.Position
						end
					elseif param1 == "TAP" and typeof(v2) == "Vector3" then
						local Target = _GetCurrentTarget("AimBot_Tap")
						
						if Target then
							return "TAP", Target.Position
						end
					end
					
					return ...
				end
			}
			
			local old_namecall;
			old_namecall = hookmetamethod(game, "__namecall", function(self, ...)
				local Event = Events[self.Name]
				
				if Event and string.lower(getnamecallmethod()) == "fireserver" then
					return old_namecall(self, Event(...))
				else
					return old_namecall(self, ...)
				end
			end)
			
			_ENV.rz_original_namecall = old_namecall
		end
		
		Module.HookGame = function()
			task.delay(1, hook_newindex)
			task.delay(1, hook_namecall)
		end
		
		function Hooking:SetTarget(RootPart: BasePart): (nil)
			ClosestEnemie, DisableUpdateClosest = GetRandomHitboxLimb(RootPart.Parent) or RootPart, tick()
		end
		
		return Hooking
	end)()
	
	-- task.defer(function()
	-- 	local DeathEffect = require(WaitChilds(ReplicatedStorage, "Effect", "Container", "Death"))
	-- 	local CameraShaker = require(WaitChilds(ReplicatedStorage, "Util", "CameraShaker"))
	-- 	
	-- 	if CameraShaker then
	-- 		CameraShaker:Stop()
	-- 	end
	-- 	if hookfunction then
	-- 		hookfunction(DeathEffect, function(...) return ... end)
	-- 	end
	-- end)
	
	task.defer(function()
		local OwnersId = { 3095250, 17884881 }
		local OwnersFriends = CreateDictionary({ 6079649301, 4985647299 }, true)
		
		local LocalPlayer = Player
		
		local StaffsItems = {
			["Triple Dark Blade"] = true
		}
		
		local BlacklistedAttributes = {"GANKS", "GANKSVolley", "AAIM"}
		
		local MaxLevel = Module.GameData.MaxLevel
		local CurrentSea = Module.GameData.Sea
		local MaxBounty = 3e7 + 250000
		
		local VerificationSteps = {
			(function(Player)
				if table.find(OwnersId, Player.UserId) then
					return true
				elseif OwnersFriends[Player.UserId] then
					return true
				end
			end),
			(function(Player, Data)
				if Data.Level.Value > MaxLevel then
					return true
				elseif Data.Beli.Value >= 3e8 and Data.Level.Value <= 700 then
					return true
				end
			end),
			(function(Player, Data)
				if CurrentSea > 1 and Data.Level.Value < 700 then
					return true
				elseif CurrentSea > 2 and Data.Level.Value < 1500 then
					return true
				end
			end),
			(function(Player)
				for i = 1, #BlacklistedAttributes do
					if Player:GetAttribute(BlacklistedAttributes[i]) then
						return true
					end
				end
			end),
			(function(Player)
				local BountyHonor = Player:WaitForChild("leaderstats"):WaitForChild("Bounty/Honor")
				
				if BountyHonor.Value > MaxBounty or BountyHonor.Value < 0 then
					return true
				end
			end)
		}
		
		local function PossibleStaff(Player)
			Module.RejoinBlocked = true
			return LocalPlayer:Kick(`{ Player.DisplayName }/@{ Player.Name } maybe it's a blox fruits admin`)
		end
		
		local function StaffCheck(Player)
			if Player == LocalPlayer then return end
			
			local Data = Player:WaitForChild("Data", 30)
			
			if Data then
				Data:WaitForChild("Level", 10)
				Data:WaitForChild("Beli", 10)
				
				for i = 1, #VerificationSteps do
					local success, isStaff = pcall(VerificationSteps[i], Player, Data)
					if success and isStaff then
						return PossibleStaff(Player)
					end
				end
			end
		end
		
		task.spawn(function()
			table.insert(Connections, Players.PlayerAdded:Connect(StaffCheck))
			for _, Player in ipairs(Players:GetPlayers()) do task.defer(StaffCheck, Player) end
		end)
		
		for _, OwnerId in OwnersId do
			local FriendsPages = Players:GetFriendsAsync(OwnerId)
			if not FriendsPages then task.wait(5) continue end
			
			while not FriendsPages.IsFinished do
				local FriendsList = FriendsPages:GetCurrentPage()
				
				for i = 1, #FriendsList do
					local Friend = FriendsList[i]
					local Player = Players:GetPlayerByUserId(Friend.Id)
					
					if Player then
						task.defer(PossibleStaff, Player)
					else
						OwnersFriends[Friend.Id] = true
					end
				end
				
				FriendsPages:AdvanceToNextPageAsync()
			end
		end
	end)
	
	task.spawn(function()
		local SpawnLocations = Module.SpawnLocations
		local EnemyLocations = Module.EnemyLocations
		
		local function NewIslandAdded(Island)
			if Island.Name:find("Island") then
				Cached.RaidIsland = nil
			end
		end
		
		local function NewSpawn(Part)
			local EnemyName = GetEnemyName(Part.Name)
			EnemyLocations[EnemyName] = EnemyLocations[EnemyName] or {}
			
			local EnemySpawn = Part.CFrame + Vector3.new(0, 25, 0)
			SpawnLocations[EnemyName] = Part
			
			if not table.find(EnemyLocations[EnemyName], EnemySpawn) then
				table.insert(EnemyLocations[EnemyName], EnemySpawn)
			end
		end
		
		for _, Spawn in EnemySpawns:GetChildren() do NewSpawn(Spawn) end
		table.insert(Connections, EnemySpawns.ChildAdded:Connect(NewSpawn))
		table.insert(Connections, Locations.ChildAdded:Connect(NewIslandAdded))
	end)
end

do
	local ToolsCache = Module.Cached.Tools
	
	local function BuyBuso()
		if Money.Value >= 25e3 then
			FireRemote("BuyHaki", "Buso")
		end
	end
	
	local function FindFirstType(Tip)
		local Equipped = Player.Character:FindFirstChildOfClass("Tool")
		
		if Equipped and Equipped.ToolTip == Tip then
			return Equipped
		end
		
		for _, Tool in Player.Backpack:GetChildren() do
			if Tool:IsA("Tool") and Tool.ToolTip == Tip then
				return Tool
			end
		end
	end
	
	function EnableBuso()
		if Settings.AutoBuso then
			local Character = Player.Character
			if IsAlive(Character) and not Character:FindFirstChild("HasBuso") then
				return if Character:HasTag("Buso") then FireRemote("Buso") else BuyBuso()
			end
		end
	end
	
	function GetTool(Name: string, ByType: boolean?): Tool?
		local Character = Player.Character
		if not IsAlive(Character) then return end
		
		local CacheTag = if ByType then `toolTip_{Name}` else Name
		local Cache = ToolsCache[CacheTag]
		
		if Cache and (Cache.Parent == Character or Cache.Parent == Player.Backpack) then
			return Cache
		end
		
		local HasTool = if ByType then FindFirstType(Name) else (Character:FindFirstChild(Name) or Player.Backpack:FindFirstChild(Name))
		
		if HasTool then
			ToolsCache[CacheTag] = HasTool
			return HasTool
		end
	end
	
	function GetToolMastery(Name: string): number
		local HasTool = GetTool(Name)
		return HasTool and HasTool:GetAttribute("Level") or 0
	end
	
	function VerifyToolTip(Tip: string): boolean
		return if GetTool(Tip, true) then true else false
	end
	
	function VerifyTool(Name: string): boolean
		return if GetTool(Name) then true else false
	end
end